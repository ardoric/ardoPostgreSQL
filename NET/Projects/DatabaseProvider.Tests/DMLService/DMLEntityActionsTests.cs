/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Data;
using NUnit.Framework;
using NUnitExtension.OutSystems.Framework;
using OutSystems.HubEdition.Extensibility.Data;
using OutSystems.HubEdition.Extensibility.Data.DMLService;
using OutSystems.HubEdition.Extensibility.Data.DMLService.DMLPlaceholders;
using OutSystems.HubEdition.Extensibility.Data.ExecutionService;
using OutSystems.RuntimeCommon;
using OutSystems.ServerTests.DatabaseProvider.Framework;

namespace OutSystems.ServerTests.DatabaseProvider.DMLService {

    [DashboardTestFixture(DashboardTest.DashboardTestKind)]
    public class DMLEntityActionsTests : DMLTest {

        private const string errorMessageFormat = "Error validating {0} action with SQL: {1}";

        private IDMLEntityActions GetDMLEntityActions(IDatabaseServices databaseServices) {
            return databaseServices.DMLService.GetEntityActions(databaseServices.ObjectFactory.CreateTableSourceInfo("DUMMY"));
        }

        [IterativeTestCase(typeof(DMLTestsConfiguration), Description = "Validates that using the placeholder values defined for the GetEntity action we can execute a select statement")]
        [TestDetails(TestIssue = "610147", Feature = "Database Abstraction Layer", CreatedBy = "mar")]
        public void TestGetEntity(DatabaseProviderTestCase tc) {
            var databaseServices = tc.Services;
            IDMLEntityActions dmlEntityActions = GetDMLEntityActions(databaseServices);
            InnerGetEntity(databaseServices, dmlEntityActions.SQLPlaceholderValuesForGet(), /*forUpdate*/ false);
        }

        [IterativeTestCase(typeof(DMLTestsConfiguration), Description = "Validates that using the placeholder values defined for the GetEntityForUpdate action we can execute a select statement")]
        [TestDetails(TestIssue = "610147", Feature = "Database Abstraction Layer", CreatedBy = "mar")]
        public void TestGetEntityForUpdate(DatabaseProviderTestCase tc) {
            var databaseServices = tc.Services;
            IDMLEntityActions dmlEntityActions = GetDMLEntityActions(databaseServices);
            InnerGetEntity(databaseServices, dmlEntityActions.SQLPlaceholderValuesForGetForUpdate(), /*forUpdate*/ true);
        }

        private void InnerGetEntity(IDatabaseServices databaseServices, IDictionary<SelectPlaceholder, string> getPlaceholders, bool forUpdate) {
            string beforeStatement = getPlaceholders.GetPlaceholderValueTrimStart(SelectPlaceholder.BeforeStatement);
            string afterSelect = getPlaceholders.GetPlaceholderValueTrimStart(SelectPlaceholder.AfterSelectKeyword);
            string beforeFrom = getPlaceholders.GetPlaceholderValueTrimStart(SelectPlaceholder.BeforeFromKeyword);
            string afterFrom = getPlaceholders.GetPlaceholderValueTrimStart(SelectPlaceholder.AfterFromKeyword);
            string beforeWhere = getPlaceholders.GetPlaceholderValueTrimStart(SelectPlaceholder.BeforeWhereKeyword);
            string afterWhere = getPlaceholders.GetPlaceholderValueTrimStart(SelectPlaceholder.AfterWhereKeyword);
            string afterStatement = getPlaceholders.GetPlaceholderValueTrimEnd(SelectPlaceholder.AfterStatement);

            string sql = beforeStatement + "SELECT " + afterSelect + "ID " + beforeFrom + "FROM " + afterFrom + "DUMMY"+MachineName+" " +
                beforeWhere + "WHERE " + afterWhere + databaseServices.DMLService.Operators.Equal("ID", "1") + afterStatement;

            var sqlExecutor = new SQLExecutor(databaseServices);
            int returnedId = sqlExecutor.ExecuteScalar(sql).RuntimeValue<int>();
            int expectedId = 1;
            AssertEqual(expectedId, returnedId, string.Format(errorMessageFormat, (forUpdate ? "GetEntityForUpdate" : "GetEntity"), sql));
        }

        [IterativeTestCase(typeof(DMLTestsConfiguration), Description = "Validates that using the placeholder values defined for the CreateEntity action we can execute an insert statement")]
        [TestDetails(TestIssue = "610147", Feature = "Database Abstraction Layer", CreatedBy = "mar")]
        public void TestCreateEntity(DatabaseProviderTestCase tc) {
            var databaseServices = tc.Services;
            IDMLEntityActions dmlEntityActions = GetDMLEntityActions(databaseServices);
            IDictionary<InsertPlaceholder, string> insertPlaceholders = dmlEntityActions.SQLPlaceholderValuesForCreate();
            string beforeStatement = insertPlaceholders.GetPlaceholderValueTrimStart(InsertPlaceholder.BeforeStatement);
            string beforeValuesKeyword = insertPlaceholders.GetPlaceholderValueTrimStart(InsertPlaceholder.BeforeValuesKeyword);
            string afterStatement = insertPlaceholders.GetPlaceholderValueTrimEnd(InsertPlaceholder.AfterStatement);

            int value = 2;
            string insertSql = beforeStatement + "INSERT INTO DUMMY"+MachineName+" (VAL) " + beforeValuesKeyword + "VALUES (" + value + ")" + afterStatement;
            string selectSql = "SELECT VAL FROM DUMMY"+MachineName+" WHERE VAL = " + value;

            ExecuteSQL(databaseServices, (service, tran) => {
                using (IDbCommand cmd = service.CreateCommand(tran, insertSql)) {
                    service.ExecuteNonQuery(cmd);
                }
                int insertedValue;
                using (IDbCommand cmd = service.CreateCommand(tran, selectSql)) {
                    insertedValue = (int)Convert.ChangeType(service.ExecuteScalar(cmd), typeof(int));
                }
                AssertEqual(value, insertedValue, string.Format(errorMessageFormat, "CreateEntity", insertSql));
                return true;
            });
        }

        [IterativeTestCase(typeof(DMLTestsConfiguration), Description = "Validates that using the placeholder values defined for the CreateEntity action we can execute an insert statement retrieving the inserted identifier")]
        [TestDetails(TestIssue = "610147", Feature = "Database Abstraction Layer", CreatedBy = "mar")]
        public void TestCreateEntityRetrievingId(DatabaseProviderTestCase tc) {
            var databaseServices = tc.Services;
            IDMLEntityActions dmlEntityActions = GetDMLEntityActions(databaseServices);

            string paramName = databaseServices.ExecutionService.ParameterPrefix + "id";
            int value = 2;
            RetrieveIdMethod retrieveIdMethod;            
            IDictionary<InsertPlaceholder, string> insertPlaceholders = dmlEntityActions.SQLPlaceholderValuesForCreateAndRetrieveId("ID", paramName, out retrieveIdMethod);

            string beforeStatement = insertPlaceholders.GetPlaceholderValueTrimStart(InsertPlaceholder.BeforeStatement);
            string beforeValuesKeyword = insertPlaceholders.GetPlaceholderValueTrimStart(InsertPlaceholder.BeforeValuesKeyword);
            string afterStatement = insertPlaceholders.GetPlaceholderValueTrimEnd(InsertPlaceholder.AfterStatement);

            string sql = beforeStatement + "INSERT INTO DUMMY"+MachineName+" (VAL) " + beforeValuesKeyword + "VALUES (" + value + ")" + afterStatement;
            if (retrieveIdMethod == RetrieveIdMethod.ReturnValue) {
                ExecuteSQL(databaseServices, (service, tran) => {
                    int returnedId;
                    using (IDbCommand cmd = service.CreateCommand(tran, sql)) {
                        returnedId = (int)Convert.ChangeType(service.ExecuteScalar(cmd), typeof(int));
                    }
                    ValidateInsertedValue(service, tran, value, returnedId, sql);
                    return true;
                });
            } else {
                ExecuteSQL(databaseServices, (service, tran) => {
                    int returnedId;
                    using (IDbCommand cmd = service.CreateCommand(tran, sql)) {
                        IDbDataParameter parameter = service.CreateParameter(cmd, paramName, DbType.Int32, null);
                        service.SetParameterDirection(parameter, ParameterDirection.Output);
                        service.ExecuteNonQuery(cmd);
                        returnedId = (int)Convert.ChangeType(parameter.Value, typeof(int));
                    }
                    ValidateInsertedValue(service, tran, value, returnedId, sql);
                    return true;
                });
            }
        }

        private void ValidateInsertedValue(IExecutionService service, IDbTransaction tran, int expectedValue, int returnedId, string executedSql) {
            string sql = "SELECT VAL FROM DUMMY"+MachineName+" WHERE ID = " + returnedId;
            using (IDbCommand cmd = service.CreateCommand(tran, sql)) {
                int insertedValue = (int)Convert.ChangeType(service.ExecuteScalar(cmd), typeof(int));
                AssertEqual(expectedValue, insertedValue, string.Format(errorMessageFormat, "CreateEntityRetrievingId", executedSql));
            }
        }

        [IterativeTestCase(typeof(DMLTestsConfiguration), Description = "Validates that using the placeholder values defined for the UpdateEntity action we can execute an update statement")]
        [TestDetails(TestIssue = "610147", Feature = "Database Abstraction Layer", CreatedBy = "mar")]
        public void TestUpdateEntity(DatabaseProviderTestCase tc) {
            var databaseServices = tc.Services;
            IDMLEntityActions dmlEntityActions = GetDMLEntityActions(databaseServices);
            IDictionary<UpdatePlaceholder, string> updatePlaceholders = dmlEntityActions.SQLPlaceholderValuesForUpdate();
            string beforeStatement = updatePlaceholders.GetPlaceholderValueTrimStart(UpdatePlaceholder.BeforeStatement);
            string beforeWhereKeyword = updatePlaceholders.GetPlaceholderValueTrimStart(UpdatePlaceholder.BeforeWhereKeyword);
            string afterStatement = updatePlaceholders.GetPlaceholderValueTrimEnd(UpdatePlaceholder.AfterStatement);

            int value = 2;
            string updateSql = beforeStatement + "UPDATE DUMMY"+MachineName+" SET VAL = " + value + " " + beforeWhereKeyword + "WHERE ID = 1" + afterStatement;
            string selectSql = "SELECT VAL FROM DUMMY"+MachineName+" WHERE ID = 1";

            ExecuteSQL(databaseServices, (service, tran) => {
                using (IDbCommand cmd = service.CreateCommand(tran, updateSql)) {
                    service.ExecuteNonQuery(cmd);
                }
                int updatedValue;
                using (IDbCommand cmd = service.CreateCommand(tran, selectSql)) {
                    updatedValue = (int)Convert.ChangeType(service.ExecuteScalar(cmd), typeof(int));
                }
                AssertEqual(value, updatedValue, string.Format(errorMessageFormat, "UpdateEntity", updateSql));
                return true;
            });
        }

        [IterativeTestCase(typeof(DMLTestsConfiguration), Description = "Validates that using the placeholder values defined for the DeleteEntity action we can execute a delete statement")]
        [TestDetails(TestIssue = "610147", Feature = "Database Abstraction Layer", CreatedBy = "mar")]
        public void TestDeleteEntity(DatabaseProviderTestCase tc) {
            var databaseServices = tc.Services;
            IDMLEntityActions dmlEntityActions = GetDMLEntityActions(databaseServices);
            IDictionary<DeletePlaceholder, string> deletePlaceholders = dmlEntityActions.SQLPlaceholderValuesForDelete();
            string beforeStatement = deletePlaceholders.GetPlaceholderValueTrimStart(DeletePlaceholder.BeforeStatement);
            string beforeWhereKeyword = deletePlaceholders.GetPlaceholderValueTrimStart(DeletePlaceholder.BeforeWhereKeyword);
            string afterStatement = deletePlaceholders.GetPlaceholderValueTrimEnd(DeletePlaceholder.AfterStatement);

            string deleteSql = beforeStatement + "DELETE FROM DUMMY"+MachineName+" " + beforeWhereKeyword + "WHERE ID = 1" + afterStatement;
            string selectSql = "SELECT VAL FROM DUMMY" + MachineName + " WHERE ID = 1";

            ExecuteSQL(databaseServices, (service, tran) => {
                using (IDbCommand cmd = service.CreateCommand(tran, deleteSql)) {
                    service.ExecuteNonQuery(cmd);
                }
                object deletedValue;
                using (IDbCommand cmd = service.CreateCommand(tran, selectSql)) {
                    deletedValue = service.ExecuteScalar(cmd);
                }
                AssertEqual(null, deletedValue, string.Format(errorMessageFormat, "DeleteEntity", deleteSql));
                return true;
            });
        }

        private void ExecuteSQL(IDatabaseServices services, Func<IExecutionService, IDbTransaction, object> execute) {
            using (IDbConnection conn = services.TransactionService.CreateConnection()) {
                IDbTransaction tran = null;
                try {
                    tran = services.TransactionService.CreateTransaction(conn);
                    execute(services.ExecutionService, tran);
                } finally {
                    if (tran != null) {
                        tran.Rollback();
                    }
                }
            }
        }
    }
}
