/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using OutSystems.HubEdition.Extensibility.Data.ExecutionService;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Log;

namespace OutSystems.HubEdition.Extensibility.Data.TransactionService {
    
    /// <summary>
    /// Represents a service to manage transactions.
    /// Extend this class to create a transaction manager.
    /// </summary>
    public class GenericTransactionManager : ITransactionManager {        
        private ITransactionService transactionService;

        /// <summary>
        /// This property represents the transaction pool used by this manager.
        /// </summary>
        /// <value>
        /// The transaction pool.
        /// </value>
        protected Hashtable TransactionPool { get; private set; }

        /// <summary>
        /// This property represents information about the request transaction.
        /// </summary>
        /// <value>The request transaction information.</value>
        protected TransactionInfo RequestTransactionInfo { get; set; }

        /// <summary>
        /// Stores information about transaction state providing methods that allow its manipulation.
        /// </summary>
        protected class TransactionInfo {
            private volatile IDbConnection _conn;
            private volatile IDbTransaction _trans;
            private volatile bool _free;
            private volatile bool _isReleasable;
            private volatile bool _isPoolable;
            private DateTime _creationTime;
            private DateTime _lastChange;
            private volatile IList<IDataReader> _readers = new List<IDataReader>();

            /// <summary>
            /// Returns true if the transaction is free.
            /// </summary>
            /// <value>
            /// True if the transaction is free, False otherwise.
            /// </value>
            public bool Free { get { return _free; } }

            /// <summary>
            /// Gets the transaction creation time.
            /// </summary>
            /// <value>
            /// The creation time.
            /// </value>
            public DateTime CreationTime { get { return _creationTime; } }

            /// <summary>
            /// Gets the time of the last modification to the transaction
            /// </summary>
            /// <value>
            /// The time when the transaction was change for last.
            /// </value>
			public DateTime LastChange { get { return _lastChange; } }

            /// <summary>
            /// Gets the number of readers associated with the transaction.
            /// </summary>
            /// <value>
            /// The number of readers associated.
            /// </value>
            public int ReaderCount { 
                get { 
                    lock (_readers) { 
                        return _readers.Where(r => !r.IsClosed).Count();
                    }
                }
            }

            /// <summary>
            /// This property informs if the transaction can be released.
            /// </summary>
            /// <value>
            /// <c>true</c> if this instance is releasable; otherwise, <c>false</c>.
            /// </value>
            public bool IsReleasable {
                get { return _isReleasable; }
                set { _isReleasable = value; }
            }

            /// <summary>
            /// This property informs if the transaction can be returned to the pool.
            /// </summary>
            /// <value>
            /// <c>true</c> if this instance is poolable; otherwise, <c>false</c>.
            /// </value>
            public bool IsPoolable {
                get { return _isPoolable; }
                set { _isPoolable = value; }
            }

            /// <summary>
            /// Returns the <see cref="IDbTransaction" /> object being wrapped.
            /// </summary>
            /// <value>
            /// The transaction.
            /// </value>
            public IDbTransaction Transaction { get { return _trans; } }

            /// <summary>
            /// Returns the <see cref="IDbConnection" /> object being wrapped.
            /// </summary>
            /// <value>
            /// The connection.
            /// </value>
            public IDbConnection Connection { get { return _conn; } }

            /// <summary>
            /// <see cref="TransactionInfo"/> constructor.
			/// Whenever possible pass in the original connection variable that created the transaction instead of just (trans, trans.Connection)
            /// It appears there is a bug in ADO.NET that makes the GC delete connections that are just referenced by a transaction, 
            /// causing the later to appear as Zombie and making <code>trans.Connection == null</code>. 
            /// Because of that, an explicit reference is kept both to the connection and the transaction.
			/// </summary>
			/// <param name="transaction">The transaction to be used.</param>
            /// <param name="connection">The connection to be used.</param>
			public TransactionInfo( IDbTransaction transaction, IDbConnection connection ) {
				_conn = connection;
                _trans = transaction;
                _creationTime = DateTime.Now;
                _lastChange = DateTime.Now;
                _free = true;
                _isPoolable = true;
                _isReleasable = true;
            }

            /// <summary>
            /// Marks the transaction as busy and changes its <see cref="LastChange"/> time.
            /// </summary>
            public void Reserve() {
                lock (this) {
                    _free = false;
                    MarkChange();
                }
            }

            /// <summary>
            /// Releases the transaction by marking it as free, changing its <see cref="LastChange"/> time
            /// time and closing all associated readers.
            /// </summary>
            public void Release() {
                lock (this) {
                    _free = true;
                    MarkChange();
                    closeReaders();
                }
            }

            /// <summary>
            /// Sets the last changed time to now.
            /// </summary>
            public void MarkChange() {
                _lastChange = DateTime.Now;
            }

            /// <summary>
            /// Associates a reader with the transaction.
            /// Before associating the reader, cleans-up closed readers.
            /// </summary>
            /// <param name="reader">The reader to associate</param>
            public void AddReader(IDataReader reader) {
                lock (_readers) {
                    // Clean-up already closed data readers, to avoid memory leaks
                    _readers.Where(r => r.IsClosed).ToArray().Apply(r => _readers.Remove(r));
                    _readers.Add(reader);
                }
            }

            /// <summary>
            /// Closes all readers associated with the transaction.
            /// </summary>
            private void closeReaders() {
                lock (_readers) {
                    foreach (IDataReader reader in _readers) {
                        if (!reader.IsClosed) reader.Close();
                    }
                    _readers.Clear();
                }
            }

            /// <summary>
            /// Closes the connection associated with the transaction.
            /// </summary>
            public void ReturnConnectionToPool() {
                if (_conn != null) {
                    _conn.Close();
                    _conn.Dispose();
                    
                    _conn = null;
                }
            }
        }

        protected TransactionInfo GetTransactionInfo(IDbTransaction trans) {
            bool isRequestTransaction;
            return GetTransactionInfo(trans, out isRequestTransaction);
        }

        protected TransactionInfo GetTransactionInfo(IDbTransaction trans, out bool isRequestTransaction) {
            if ((RequestTransactionInfo != null) && RequestTransactionInfo.Transaction.Equals(trans)) {
                isRequestTransaction = true;
                return RequestTransactionInfo;
            } else {
                isRequestTransaction = false;
                return (TransactionInfo) TransactionPool[trans];
            }
        }
        
        /// <summary>
        /// Returns a <see cref="TransactionInfo"/> instance built with a connection and a transaction created by the associated TransactionService.
        /// </summary>
        /// <returns>A new <see cref="TransactionInfo"/> instance.</returns>
        protected TransactionInfo BuildTransactionInfo() {
            IDbTransaction trans;
            IDbConnection conn;            

            conn = GetConnection();
            trans = transactionService.CreateTransaction(conn);

            return new TransactionInfo(trans, conn);
        }

        /// <summary>
        /// This property represents the <see cref="ITransactionService"/> associated with this transaction manager.
        /// When setting this property, all resources are released and transactions are rolled back.
        /// </summary>
        public virtual ITransactionService TransactionService {
            get {
                return transactionService;
            }
            set {
                FreeupResources(false);  //remove from pool all transactions (they have the old connection string)
                transactionService = @value;
            }
        }

        /// <summary>
        /// Gets the <see cref="IExecutionService" /> created by the associated DatabaseService.
        /// </summary>
        /// <value>
        /// The execution service associated.
        /// </value>
        public IExecutionService ExecutionService { get { return transactionService.DatabaseServices.ExecutionService; } }

        /// <summary>
        /// Gets the number of busy transactions.
        /// </summary>
        public virtual int BusyTransactionCount {
            get {
                int counter = 0;
                foreach (TransactionInfo info in TransactionPool.Values) {
                    if (!info.Free) counter++;
                }
                return counter;
            }
        }

        /// <summary>
        /// Returns a transaction to be used during a web request.
        /// This transaction is only committed or rolled back by invoking <see cref="FreeupResources"/>.
        /// </summary>
        /// <returns>A transaction to be used in the applications.</returns>
        public virtual IDbTransaction GetRequestTransaction() {
            lock (this) {
                if (RequestTransactionInfo == null) {
                    RequestTransactionInfo = BuildTransactionInfo();
                }

                //must discard it and make a new one if the connection is null #52135
                if (RequestTransactionInfo.Transaction.Connection == null || RequestTransactionInfo.Transaction.Connection.State == ConnectionState.Closed) {
                    if (RequestTransactionInfo.Transaction.Connection != null) {
                        RequestTransactionInfo.ReturnConnectionToPool();
                    }
                    RequestTransactionInfo = null;
                    while (RequestTransactionInfo == null) {

                        RequestTransactionInfo = BuildTransactionInfo();

                        if (RequestTransactionInfo.Transaction.Connection == null || RequestTransactionInfo.Transaction.Connection.State == ConnectionState.Closed) {
                            if (RequestTransactionInfo.Transaction.Connection != null) {
                                RequestTransactionInfo.ReturnConnectionToPool();
                            }


                            // only log error in the second try
                            LogException(new InvalidTransactionException("Connection in transaction is null."), new StackTrace(), "Releasing connection pools and retrying");

                            RequestTransactionInfo = null; // retry
                            TransactionService.ReleasePooledConnections("Connection in transaction is null.");
                            Thread.Sleep(TransactionServiceConstants.RETRY_CONNECTION_TIME);
                        }
                    }
                }

                RequestTransactionInfo.MarkChange();
                return RequestTransactionInfo.Transaction;
            }
        }

        /// <summary>
        /// Returns a transaction that is managed by extension developers.
        /// Extension developers explicitly commit or rollback this transaction.
        /// </summary>
        /// <returns>A committable transaction managed by the user.</returns>
        public virtual IDbTransaction GetCommitableTransaction() {
            TransactionInfo transInfo = AddToPoolAndReserve();
            transInfo.IsPoolable = false;
            transInfo.IsReleasable = false;
            return transInfo.Transaction;
        }

        /// <summary>
        /// Returns a transaction with read only access suitable to iterate results.
        /// </summary>
        /// <returns>A Transaction only for read purposes.</returns>
        public virtual IDbTransaction GetReadOnlyTransaction() {
            if (TransactionService.DatabaseServices.DatabaseConfiguration.DatabaseProvider.Properties.SupportsMultipleActiveResultSets) {
                return GetRequestTransaction();
            } else {
                //#52135 fetching pooled transactions is already protected against null connections
                return GetAndReserveFromPool().Transaction;
            }
        }

        protected TransactionInfo GetAndReserveFromPool() {
            TransactionInfo transInfo = null;

            while (transInfo == null) {
                try {
                    transInfo = GetAndReserveFromPoolUnchecked();
                } catch (InvalidTransactionException e) {
                    LogException(e, new StackTrace(), "Transaction discarded from pool. Obtaining another transaction and retrying");
                    transInfo = null; // retry
                }
            }
            return transInfo;
        }

        protected TransactionInfo GetAndReserveFromPoolUnchecked() {
            TransactionInfo[] transactions;
            lock (TransactionPool.SyncRoot) {
                transactions = TransactionPool.Values.Cast<TransactionInfo>().ToArray();
            }

            foreach (TransactionInfo transInfo in transactions) {
                if (transInfo.Free) {
                    lock (transInfo) {
                        if (transInfo.Free) {
                            DateTime lastChange = transInfo.LastChange;
                            transInfo.Reserve();

                            //#52135, we already have nice checks for the pooled connections
                            if (transInfo.Transaction.Connection == null || transInfo.Connection.State == ConnectionState.Closed) {
                                // build exception report
                                IDbConnection shadowConnection = transInfo.Connection;
                                string exceptTxt = "Connection in transaction is null or closed (TransactionInfo Status: ";
                                try {
                                    if (shadowConnection == null) {
                                        exceptTxt += "Connection=null, ";
                                    } else {
                                        exceptTxt += String.Format("Connection.State=='{0}', ", shadowConnection.State.ToString());
                                    }

                                    exceptTxt += String.Format("Free='{0}', CreationTime='{1}', LastChange='{2}', ReaderCount='{3}')",
                                        transInfo.Free, transInfo.CreationTime, lastChange, transInfo.ReaderCount);

                                    int numTransactions = transactions.Length;
                                    int numFree = CountFreeTransactionsInPool(transactions);
                                    exceptTxt += String.Format(". (Pool Status: Total={0}, Free={1})", numTransactions, numFree);
                                } catch {
                                } finally {
                                    // remove and cleanup everything
                                    TransactionPool.Remove(transInfo.Transaction);

                                    transInfo.Transaction.Dispose();

                                    if (transInfo.Connection != null) {
                                        transInfo.Connection.Dispose();
                                    }
                                }
                                throw new InvalidTransactionException(exceptTxt);
                            } else {
#if DEBUG_DBCONNECTIONPOOLING
                                OSTrace.Info("DBConnectionPooling[TID=" + transInfo.Transaction.GetHashCode() + "] - reserved from pool");
                                OSTrace.Error(new StackTrace().ToString());
#endif
                                return transInfo;
                            }
                        }
                    }
                }
            }
            // No free transaction found. Add a new one and return it.
            return AddToPoolAndReserve();
        }

        protected TransactionInfo AddToPoolAndReserve() {
            lock (this) {
                TransactionInfo transInfo = null;
                while (transInfo == null) {
                    transInfo = BuildTransactionInfo();
                    transInfo.Reserve();

                    //drivers doesn't ensure connection is good so make sure
                    if (transInfo.Transaction.Connection == null || transInfo.Transaction.Connection.State == ConnectionState.Closed) {
                        if (transInfo.Transaction.Connection != null) {
                            transInfo.ReturnConnectionToPool();
                        }
                        LogException(new InvalidTransactionException("Connection in transaction is null."), new StackTrace(), "Releasing connection pools and retrying");
                        transInfo = null; // retry;
                        TransactionService.ReleasePooledConnections("Connection in transaction is null.");
                        Thread.Sleep(TransactionServiceConstants.RETRY_CONNECTION_TIME);
                    }
                }

#if DEBUG_DBCONNECTIONPOOLING
                OSTrace.Info("DBConnectionPooling[TID=" + transInfo.Transaction.GetHashCode() + "] - reserved from pool");
                OSTrace.Error(new StackTrace().ToString());
#endif
                TransactionPool.Add(transInfo.Transaction, transInfo);
                return transInfo;
            }
        }

        private int CountFreeTransactionsInPool(TransactionInfo[] transactions) {
            int numFree = 0;
            foreach (TransactionInfo transInfoTmp in transactions) {
                if (transInfoTmp.Free) {
                    numFree++;
                }
            }
            return numFree;
        }

        /// <summary>
        /// Returns a database connection created by the associated <see cref="TransactionService"/>.
        /// </summary>
        /// <returns>A new connection to the database</returns>
        protected IDbConnection GetConnection() {
            return transactionService.CreateConnection();
        }

        /// <summary>
        /// Releases a transaction to the pool.
        /// If the transaction is poolable, it is released and put back into the pool, otherwise it is removed.
        /// Throws an <see cref="InvalidTransactionReleaseException"/> if the transaction is not releasable.
        /// </summary>
        /// <exception cref="InvalidTransactionReleaseException">Occurs if the transaction is not releasable.</exception>
        /// <param name="trans">Transaction to be released.</param>
        public virtual void ReleaseTransaction(IDbTransaction trans) {
            if (trans == null) return;
            TransactionInfo transInfo = (TransactionInfo)TransactionPool[trans];
            if (transInfo != null) {
                if (!transInfo.IsReleasable) throw (new InvalidTransactionReleaseException("Cannot release a transaction that was created with \"GetCommitableTransaction\". Use commit or rollback"));
#if DEBUG_DBCONNECTIONPOOLING
                OSTrace.Info("DBConnectionPooling[TID=" + transInfo.Transaction.GetHashCode() + "] - returned to pool");
                OSTrace.Error(new StackTrace().ToString());
#endif
                if (transInfo.IsPoolable) {
                    transInfo.Release();
                } else {
                    TransactionPool.Remove(trans);
                }
            } else {
                try {
                    if (RequestTransactionInfo != null && trans == RequestTransactionInfo.Transaction) {
                        //when releasing the request transaction make sure the connection is ok
                        if (trans.Connection != null && trans.Connection.State != ConnectionState.Open) {
                            LogException(new InvalidTransactionException("Request transaction not open on release."), new StackTrace(), "Request Transaction discarded due to connection not being in a correct state.");
                            //clear and try to dispose connection
                            lock (this) {
                                RequestTransactionInfo = null;
                            }
                            trans.Connection.Dispose();
                        } else {
                            RequestTransactionInfo.MarkChange();
                        }
                    }
                } catch {
                    //this is a best effort 
                }
            }
        }

        /// <summary>
        /// Commits a transaction.
        /// The transaction is committed, the connection is closed and put back into the pool.
        /// </summary>
        /// <param name="trans">The transaction to be committed.</param>
        public virtual void CommitTransaction(IDbTransaction trans) {
            EndCommitableTransaction(trans, true);
        }

        /// <summary>
        /// Rolls back a transaction.
        /// The transaction is rolled back, the connection is closed and put back into the pool.
        /// </summary>
        /// <param name="trans">Transaction to be rolled back.</param>
        public virtual void RollbackTransaction(IDbTransaction trans) {
            EndCommitableTransaction(trans, false);
        }


        /// <summary>
        /// Commits all Request transactions.
        /// </summary>
        public virtual void CommitAllTransactions() {
            if (RequestTransactionInfo != null) {
                SafeEndTransaction(RequestTransactionInfo, true, /*toFreeResources*/false);
            }
            if (RequestTransactionInfo != null && (RequestTransactionInfo.Connection == null ||  RequestTransactionInfo.Transaction == null || RequestTransactionInfo.Transaction.Connection == null)) {
                RequestTransactionInfo.ReturnConnectionToPool();
                RequestTransactionInfo = null;
            }
            if (RequestTransactionInfo == null) {
                GetRequestTransaction(); // Set a new request transaction
            }
        }

        /// <summary>
        /// Rolls back all Request transactions.
        /// </summary>
        public virtual void RollbackAllTransactions() {
            if (RequestTransactionInfo != null) {
                SafeEndTransaction(RequestTransactionInfo, false, /*toFreeResources*/false);
            }
            if (RequestTransactionInfo != null && (RequestTransactionInfo.Connection == null || RequestTransactionInfo.Transaction == null || RequestTransactionInfo.Transaction.Connection == null)) {
                RequestTransactionInfo.ReturnConnectionToPool();
                RequestTransactionInfo = null;
            }
            if (RequestTransactionInfo == null) {
                GetRequestTransaction(); // Set a new request transaction
            }
        }

        /// <summary>
        /// Ends a transaction by committing or rolling back.
        /// </summary>
        /// <param name="trans">Transaction to commit.</param>
        /// <param name="commit">If True, the transaction is committed, otherwise is rolled back.</param>
        protected void EndCommitableTransaction(IDbTransaction trans, bool commit) {
            if (RequestTransactionInfo != null && RequestTransactionInfo.Transaction.Equals(trans)) {
                throw (new InvalidCommitOrRollbackTransactionException("Cannot " + (commit ? "commit" : "rollback") + " this transaction: Possibly already closed by a Thread"));
            } else {
                if (trans != null) {
                    TransactionInfo transInfo = (TransactionInfo)TransactionPool[trans];
                    if (transInfo != null) {
                        if (transInfo.IsPoolable) {
                            throw new InvalidCommitOrRollbackTransactionException("Cannot " + (commit ? "commit" : "rollback")
                                + " a transaction that was created with \"GetTransaction\". Use Release.");
                        }

                        SafeEndTransaction(transInfo, commit, /*toFreeResources*/false);
                    }
                }
            }
        }

        private void SafeEndTransaction(TransactionInfo transInfo, bool commit, bool toFreeResources) {
            try {
#if DEBUG_DBCONNECTIONPOOLING
                OSTrace.Info("DBConnectionPooling[TID=" + transInfo.Transaction.GetHashCode() + "] - returned to pool");
                OSTrace.Error(new StackTrace().ToString());
#endif
                EndTransaction(transInfo, commit, toFreeResources);
            } catch (Exception e) {
#if DEBUG_DBCONNECTIONPOOLING
                OSTrace.Error("DBConnectionPooling[TID=" + transInfo.Transaction.GetHashCode() + "]");
                OSTrace.Error(new StackTrace().ToString());
#endif
                EventLogger.WriteError(String.Format("Error closing the transaction to the database: {0}\n{1}\n{2}", e.Message, e.StackTrace,
                    new StackTrace(true)));
            }
        }

        /// <summary>
        /// Ends a pooled transaction, performing additional cleanup code if necessary.
        /// An error if an exception is raised.
        /// </summary>
        /// <param name="transInfo">Object containing information about the transaction.</param>
        /// <param name="commit">If True, all transaction are committed. Otherwise, they are rolled back.</param>
        /// <param name="toFreeResources">If True, all resources are released and connections returned to the pool.</param>
        protected virtual void EndTransaction(TransactionInfo transInfo, bool commit, bool toFreeResources) {
            TransactionPool.Remove(transInfo.Transaction);
            transInfo.Release();
            try {
                if (commit) {
                    transInfo.Transaction.Commit();
                } else {
                    transInfo.Transaction.Rollback();
                }
            } finally {
                transInfo.ReturnConnectionToPool();
            }
        }

        /// <summary>
        /// Releases all database resources being used.
        /// All transactions are committed or rolled back, and connections are returned to the pool.
        /// This implementation calls the <see cref="EndTransaction"/> method to end the transactions
        /// and sets the <see cref="RequestTransactionInfo"/> to Null.
        /// </summary>
        /// <param name="commit">If True, all transaction are committed. Otherwise, they are rolled back.</param>
        public virtual void FreeupResources(bool commit) {
            lock (TransactionPool.SyncRoot) {
                // Note: The "new ArrayList" duplicates the values because "endTransaction" deletes them.
                foreach (TransactionInfo transInfo in TransactionPool.Values.Cast<TransactionInfo>().ToArray()) {
                    SafeEndTransaction(transInfo, commit, /*toFreeResources*/true);
                }
            }

            lock (this) {
                if (RequestTransactionInfo != null) {
                    SafeEndTransaction(RequestTransactionInfo, commit, /*toFreeResources*/true);
                    RequestTransactionInfo = null;
                }
            }
        }

        /// <summary>
        /// Associates a reader to a transaction.
        /// </summary>
        /// <param name="trans">The transaction that will be associated with the reader.</param>
        /// <param name="reader">The reader to associate.</param>
        /// <returns>Returns True if the reader was successfully associated, False otherwise.</returns>
        public virtual bool AssociateReader(IDbTransaction trans, IDataReader reader) {
            TransactionInfo info = GetTransactionInfo(trans);

            if (info != null) {
                info.AddReader(reader);
                return true;
            }
            return false;
        }

        /// <summary>
        /// Logs an error with information about the exception, the stack trace and a message.
        /// </summary>
        /// <param name="e">Exception to log.</param>
        /// <param name="additionalStack">Stack trace to add to the log.</param>
        /// <param name="additionalMessage">Message to add to the log.</param>
        protected void LogException(Exception e, StackTrace additionalStack, string additionalMessage) {
            try {
				String additionalStackString = (additionalStack!=null ? additionalStack.ToString() : "");
                OSTrace.Error((e != null ? e.Message : "") + Environment.NewLine + additionalMessage +
					(e != null && e.StackTrace != null ? e.StackTrace.ToString() + (String.IsNullOrEmpty(additionalStackString) ? "" : "\n" + additionalStackString) : additionalStackString));
            } catch {
            }
        }

        /// <summary>
        /// Checks if this manager is managing a given transaction.
        /// This implementation, checks if the <see cref="TransactionInfo"/> 
        /// returned by the <see cref="GetTransactionInfo(System.Data.IDbTransaction)"/> is not null.
        /// </summary>
        /// <param name="trans">The transaction.</param>
        /// <returns>Returns True if the transaction belongs to this transaction manager, False otherwise.</returns>
        public virtual bool IsManaging(IDbTransaction trans) {
            return GetTransactionInfo(trans) != null;
        }
        
        /// <summary>
        /// Creates a new instance of the <see cref="GenericTransactionManager"/> class.
        /// </summary>
        /// <param name="transactionService">The transaction service to be used.</param>
        public GenericTransactionManager(ITransactionService transactionService) {
            this.transactionService = transactionService;        
            TransactionPool = Hashtable.Synchronized(new Hashtable());
        }

        private bool isDisposed;

        /// <summary>
        /// Frees all resources and rolls back existing transactions.
        /// </summary>
        public void Dispose() {
            try {
                if (!isDisposed) {
                    FreeupResources(/*commit*/ false);
                }
            } catch (Exception e) {
                // avoid errors during dispose
#if DEBUG
                throw new Exception("Crashed on dispose, check for leaks!!!!", e);
#else
                OSTrace.Error("Exception on Dispose", e);
#endif
            } finally {
                isDisposed = true;
            }
        }

        /// <summary>
        /// Aborts a transaction and releases it.
        /// </summary>
        /// <param name="trans">Transaction to be aborted.</param>
        public void AbortTransaction(IDbTransaction trans) {
            if (trans == null) {
                return;
            }

            bool isRequestTransaction;
            TransactionInfo transInfo = GetTransactionInfo(trans, out isRequestTransaction);

            if (transInfo != null) {
#if DEBUG_DBCONNECTIONPOOLING
                OSTrace.Info("DBConnectionPooling[TID=" + transInfo.Transaction.GetHashCode() + "] - returned to pool");
                OSTrace.Error(new StackTrace().ToString());
#endif

                transInfo.Release();

                if (isRequestTransaction) {
                    RequestTransactionInfo = null;
                } else {
                    TransactionPool.Remove(transInfo.Transaction);
                }

                transInfo.ReturnConnectionToPool();
            }
        }

    }
}
